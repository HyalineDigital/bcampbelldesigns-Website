{"history":[{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"gradient","usesPingPong":false,"speed":0.25,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform vec2 uMousePos;vec3 getColor(int index) {\nswitch(index) {\ncase 0: return vec3(0.5058823529411764, 0, 0.36470588235294116);\ncase 1: return vec3(0, 0, 0);\ncase 2: return vec3(0, 0, 0);\ncase 3: return vec3(0, 0, 0);\ncase 4: return vec3(0, 0, 0);\ncase 5: return vec3(0, 0, 0);\ncase 6: return vec3(0, 0, 0);\ncase 7: return vec3(0, 0, 0);\ncase 8: return vec3(0, 0, 0);\ncase 9: return vec3(0, 0, 0);\ncase 10: return vec3(0, 0, 0);\ncase 11: return vec3(0, 0, 0);\ncase 12: return vec3(0, 0, 0);\ncase 13: return vec3(0, 0, 0);\ncase 14: return vec3(0, 0, 0);\ncase 15: return vec3(0, 0, 0);\ndefault: return vec3(0.0);\n}\n}const float PI = 3.14159265;vec2 rotate(vec2 coord, float angle) {\nfloat s = sin(angle);\nfloat c = cos(angle);\nreturn vec2(\ncoord.x * c - coord.y * s,\ncoord.x * s + coord.y * c\n);\n}out vec4 fragColor;vec3 getColor(vec2 uv) {return vec3(0.5058823529411764, 0, 0.36470588235294116);\n}void main() {vec2 uv = vTextureCoord;\nvec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nuv -= pos;\nuv /= (0.5000*2.);\nuv = rotate(uv, (0.0000 - 0.5) * 2. * PI);\nvec4 color = vec4(getColor(uv), 1.0000);\nfragColor = color;\n}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = aTextureCoord;\n}"],"data":{"downSample":0.5,"depth":false,"uniforms":{},"isBackground":true},"id":"effect"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"sdf_shape","usesPingPong":false,"texture":false,"speed":0.5,"trackMouseMove":0,"trackAxes":"xy","mouseMomentum":0,"trackMouse":0,"animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;\nprecision highp int;in vec2 vTextureCoord;\nuniform sampler2D uTexture;uniform float uTime;uniform vec2 uMousePos;\nuniform vec2 uResolution;uvec2 pcg2d(uvec2 v) {\nv = v * 1664525u + 1013904223u;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nv ^= v >> 16;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nreturn v;\n}float randFibo(vec2 p) {\nuvec2 v = floatBitsToUint(p);\nv = pcg2d(v);\nuint r = v.x ^ v.y;\nreturn float(r) / float(0xffffffffu);\n}const float PI = 3.141592653;\nconst float PI2 = 6.283185306;\nconst int DISP_STEPS = 12;\nconst vec3 viewDir = vec3(0,0, -4.25);ivec2 customTexSize;\nfloat customTexAspect;const mat3 ROT_Y_90 = mat3(\n0.0, 0.0, 1.0,\n0.0, 1.0, 0.0,\n-1.0, 0.0, 0.0\n);const mat3 ROT_Z_90 = mat3(\n0.0, -1.0, 0.0,\n1.0, 0.0, 0.0,\n0.0, 0.0, 1.0\n);const mat3 ROT_X_90 = mat3(\n1.0, 0.0, 0.0,\n0.0, 0.0, -1.0,\n0.0, 1.0, 0.0\n);mat3 rotY(float ang) {\nfloat c = cos(ang), s = sin(ang);\nreturn mat3(c, 0.0, s, 0.0, 1.0, 0.0, -s, 0.0, c);\n}mat3 rotX(float ang) {\nfloat c = cos(ang), s = sin(ang);\nreturn mat3(1.0, 0.0, 0.0, 0.0, c, -s, 0.0, s, c);\n}mat3 rotZ(float ang) {\nfloat c = cos(ang), s = sin(ang);\nreturn mat3(c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0);\n}vec3 twistY(vec3 p, float amount) {\nfloat c = cos(amount * p.y);\nfloat s = sin(amount * p.y);\nmat2 m = mat2(c, -s, s, c);\nreturn vec3(m * p.xz, p.y);\n}vec3 twistX(vec3 p, float amount) {\nfloat c = cos(amount * p.x);\nfloat s = sin(amount * p.x);\nmat2 m = mat2(c, -s, s, c);\nreturn vec3(p.x, m * p.yz);\n}float opSmoothUnion( float d1, float d2, float k ) {\nfloat h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\nreturn mix( d2, d1, h ) - k*h*(1.0-h);\n}float sdfCylinderX(vec3 p, float radius, float height) {\nvec2 d = abs(vec2(length(p.yz) - radius, p.x)) - vec2(radius, height * 0.5);\nreturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}float sdfCylinderY(vec3 p, float radius, float height) {\nvec2 d = abs(vec2(length(p.xz) - radius, p.y)) - vec2(radius, height * 0.5);\nreturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}float sdfCylinderZ(vec3 p, float radius, float height) {\nvec2 d = abs(vec2(length(p.xy) - radius, p.z)) - vec2(radius, height * 0.5);\nreturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}float sdfMergedCylinders(vec3 p, float radius, float height) {\nfloat dX = sdfCylinderX(p, radius, height);\nfloat dY = sdfCylinderY(p, radius, height);\nfloat dZ = sdfCylinderZ(p, radius, height);\nreturn opSmoothUnion(opSmoothUnion(dX, dY, 0.5), dZ, 0.5);\n}float sdStar5(vec2 p, float r, float rf)\n{\nconst vec2 k1 = vec2(0.809016994375, -0.587785252292);\nconst vec2 k2 = vec2(-k1.x,k1.y);\np.x = abs(p.x);\np -= 2.0*max(dot(k1,p),0.0)*k1;\np -= 2.0*max(dot(k2,p),0.0)*k2;\np.x = abs(p.x);\np.y -= r;\nvec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\nfloat h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r );\nreturn length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y);\n}vec3 getRepeat(vec3 p) {\nfloat spacing = (0.5000 + 0.0000 * 0.38) * 8.;\nreturn p;\n}vec3 getThreeDRepeat(vec3 p) {\nfloat spacing = (0.5000 + 0.0000 * 0.38) * 8.;\nreturn p;\n}vec3 getAdjustedP(vec3 p) {\nfloat scale = max(0.9320, 0.000000001);\nfloat scaleFactor = 1.0/scale;\nvec3 adjustedP = p * scaleFactor;vec2 twist = vec2(0, 0);adjustedP.xy *= vec2(uResolution.x / uResolution.y, 1);adjustedP *= (1. + (0.0000 + 0.01));vec2 mousePos = mix(vec2(0), uMousePos - 0.5, 0.0000);\nvec2 axis = vec2(-1. * vec3(0.42160278745644597, 0.3717770034843205, 0.3996).y - 1. + mousePos.y/PI, vec3(0.42160278745644597, 0.3717770034843205, 0.3996).x + mousePos.x/PI) * 2.;adjustedP = getRepeat(adjustedP);float baseTime = uTime * 0.02;\nfloat timeX = vec3(0, 1, 0).x * baseTime;\nfloat timeY = vec3(0, 1, 0).y * baseTime;\nfloat timeZ = vec3(0, 1, 0).z * baseTime;mat3 rotYMat = rotY(axis.y * PI);\nmat3 rotXMat = rotX(axis.x * PI);\nmat3 rotZMat = rotZ(vec3(0.42160278745644597, 0.3717770034843205, 0.3996).z * 2.0 * PI);mat3 combinedRotation = rotZMat * rotYMat * rotXMat;\nmat3 combinedAnimation = rotZ(timeZ) * rotX(timeX) * rotY(timeY);adjustedP = combinedRotation * adjustedP;\nadjustedP = combinedAnimation * adjustedP;\nadjustedP = getThreeDRepeat(adjustedP);\nadjustedP = mix(adjustedP, twistY(adjustedP, -1.0 * twist.y), step(0.0, abs(twist.y)));\nadjustedP = mix(adjustedP, twistX(adjustedP, -1.0 * twist.x), step(0.0, abs(twist.x)));return adjustedP;\n}float getMergedSDF(vec3 p) {\np = getAdjustedP(p);\nreturn sdfMergedCylinders(p, 0.2, 1. + 3. * 0.5000);\n}float fresnel(vec3 eyeVector, vec3 worldNormal, float power) {\nfloat NdotV = abs(dot(eyeVector, worldNormal));\nfloat width = fwidth(dot(eyeVector, worldNormal));\nfloat threshold = 0.2;\nfloat edgeDampFactor = smoothstep(threshold, -threshold, width);\nfloat fresnelFactor = 1.0 - NdotV;\nreturn pow(fresnelFactor, power) * mix(1., edgeDampFactor * 2., 0.5);\n}vec3 noFrostOrDispersion(vec3 rd, vec3 normal) {\nfloat ior = 1.0 / (1.0 + 0.5000 * 0.25);\nvec3 refractedRay = refract(rd, normal, ior);\nreturn texture(uTexture, vTextureCoord - refractedRay.xy).rgb;\n}vec3 frostOrDispersion(vec3 rd, vec3 normal) {\nvec3 refractionColor = vec3(0);\nfloat iorBase = 1. + 0.5000 * 0.25;vec3 dispCoefficients = vec3(0.03, 0.06, 0.1) * 0.2500 * 1.2;for (int i = 0; i < DISP_STEPS; ++i) {\nfloat step = float(i) / float(DISP_STEPS);\nvec3 disp = step * dispCoefficients;\nvec3 ior = 1.0 / (iorBase + disp);vec3 refractedRayR = refract(rd, normal, ior.r);\nvec3 refractedRayG = refract(rd, normal, ior.g);\nvec3 refractedRayB = refract(rd, normal, ior.b);refractionColor.r += texture(uTexture, vTextureCoord - refractedRayR.xy).r;\nrefractionColor.g += texture(uTexture, vTextureCoord - refractedRayG.xy).g;\nrefractionColor.b += texture(uTexture, vTextureCoord - refractedRayB.xy).b;\n}return clamp(refractionColor / float(DISP_STEPS), 0.0, 1.0);\n}vec3 calculateNormal(vec3 p, float eps) {\nvec2 e = vec2(1.0, -1.0) * eps * 0.5;\nreturn normalize(\ne.xyy * getMergedSDF(p + e.xyy) +\ne.yyx * getMergedSDF(p + e.yyx) +\ne.yxy * getMergedSDF(p + e.yxy) +\ne.xxx * getMergedSDF(p + e.xxx)\n);\n}vec3 sampleTexture(vec3 rd, vec3 normal) {return frostOrDispersion(rd, normal);\nreturn noFrostOrDispersion(rd, normal);\n}float scene(vec3 p) {\nreturn max(0.0000000001, getMergedSDF(p) - (0.0000 + 0.005)) * max(0.9320, 0.000000001);\n}const int STEPS = 128;\nconst float MAX_DISTANCE = 100.0;vec4 rayMarch(vec3 ro, vec3 rd) {\nfloat pixelSize = 0.0025;\nfloat traveled = 0.;\nvec3 entryPoint = vec3(0.0);\nvec3 entryNormal = vec3(0.0);\nfloat partialAlpha = 0.0;\nfloat lastDistance = 0.0;\nfloat smoothing = mix(1., 4., 0.2000);for (int i = 0; i < STEPS; ++i) {\nvec3 currentPos = ro + rd * traveled;\nfloat distance = scene(currentPos);\nfloat progress = float(i)/float(STEPS);\nfloat step = distance * mix(1., 1.5, progress);if (distance > MAX_DISTANCE) break;if (distance < pixelSize) {\npartialAlpha = 1.;\nentryPoint = currentPos;\nentryNormal = calculateNormal(entryPoint, pixelSize * smoothing);\nbreak;\n}lastDistance = distance;traveled += max(step, pixelSize);\nif (traveled > MAX_DISTANCE) break;\n}if (partialAlpha == 0.0) {\nreturn texture(uTexture, vTextureCoord);\n}vec3 samplePosition = mix(rd, entryPoint, 0.0000);vec3 refractionColor = texture(uTexture, vTextureCoord).rgb;refractionColor = sampleTexture(samplePosition, entryNormal);\nvec3 lightDir = vec3(((vec2(vec3(0.25, 0.25, -3).x, 1.-vec3(0.25, 0.25, -3).y) - 0.333) * 3.) - vec2(0.5, 0.5), vec3(0.25, 0.25, -3).z);\nvec3 normLightDir = normalize(lightDir);float lightAndShadow = dot(entryNormal, normLightDir);\nvec3 lightColor = mix(vec3(1), vec3(1, 1, 1), 1. - 0.0000);\nvec3 fresnelEffect = vec3(0.0);fresnelEffect = fresnel(rd, entryNormal, 8.0) * 0.5000 * vec3(1, 1, 1);vec3 specularEffect = vec3(0.0);vec3 halfwayDir = normalize(lightDir + rd);\nfloat specFactor = pow(max(dot(entryNormal, halfwayDir), 0.0), 64.0 * 0.5000 + 0.01);\nspecularEffect = specFactor * 0.5000 * lightColor;vec3 combinedEffects = fresnelEffect + specularEffect;\nvec3 finalColor = mix(refractionColor, vec3(1, 1, 1) * lightAndShadow, 0.0000);\nfinalColor += combinedEffects;vec4 outputColor = vec4(finalColor, 1.);return outputColor;\n}out vec4 fragColor;void main() {\nvec4 col = vec4(0);\nvec4 bg = texture(uTexture, vTextureCoord);if(0.9320 <= 0.0001 || 1.0000 <= 0.0001) {\ncol = vec4(0);\nif(1 == 1) {\ncol = bg;\n}\nfragColor = col;\nreturn;\n}vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nvec2 uv = vTextureCoord - pos;\nfloat fovFactor = tan(radians(20.) * 0.5);\nvec3 rd = vec3(uv * fovFactor, 0.5);\ncol = rayMarch(viewDir, rd);\nfloat dither = (randFibo(vTextureCoord.xy) - 0.5) / 255.0;\ncol += dither;col = mix(bg, col, 1.0000);\nfragColor = col;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect1"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"swirl","usesPingPong":false,"speed":0.6,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float;\nin vec3 vVertexPosition;\nin vec2 vTextureCoord;\nuniform sampler2D uTexture;\nuniform float uTime;\nuniform vec2 uMousePos;\nuniform vec2 uResolution;out vec4 fragColor;\nvoid main() {\nvec2 uv = vTextureCoord;\nfloat angle = 0.9600 * 10.;\nvec2 originalUV = uv;\nvec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);uv -= pos;\nvec2 R = vec2(uv.x * uResolution.x / uResolution.y, uv.y);\nfloat distanceToCenter = length(R);\ndistanceToCenter += 0.3200*0.5;\nif (distanceToCenter <= 1.3420) {\nfloat rot = atan(R.y, R.x) + angle * smoothstep(1.3420, 0., distanceToCenter);\nuv = vec2(cos(rot + uTime / 20. + 0.0135 * 6.28), sin(rot + uTime / 20. + 0.0135 * 6.28));\nuv = distanceToCenter * uv + pos;\n}\nfloat t = smoothstep(0., 1.3420, distanceToCenter);\nvec2 mixedUV = mix(uv, originalUV, t);vec4 color = texture(uTexture, mix(vTextureCoord, mixedUV, 1.0000));\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect2"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"noiseBlur","usesPingPong":false,"scale":0.18,"speed":0.31,"texture":false,"animating":true,"mouseMomentum":0,"isMask":0,"states":{"appear":[{"local":{"pendingChanges":{},"changeDebouncer":null,"dragSession":null},"type":"appear","id":"97c713b9-fc91-40bb-9cfb-2bc0fc0d7a6a","prop":"scale","transition":{"delay":0,"ease":"i=>i<.5?(1-Math.sqrt(1-(2*i)**2))/2:(Math.sqrt(1-Math.pow(-2*i+2,2))+1)/2","duration":2731},"complete":false,"progress":0,"value":0.258,"endValue":1,"initialized":false,"breakpoints":[],"loop":"reverse","loopDelay":0,"uniformData":{"type":"1f","name":"uScale"}}],"scroll":[],"hover":[]},"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform sampler2D uTexture;uniform float uTime;\nuniform float uScale;uniform vec2 uResolution;vec4 permute(vec4 t) {\nreturn t * (t * 34.0 + 133.0);\n}vec3 grad(float hash) {\nvec3 cube = mod(floor(hash / vec3(1.0, 2.0, 4.0)), 2.0) * 2.0 - 1.0;\nvec3 cuboct = cube;float index0 = step(0.0, 1.0 - floor(hash / 16.0));\nfloat index1 = step(0.0, floor(hash / 16.0) - 1.0);cuboct.x *= 1.0 - index0;\ncuboct.y *= 1.0 - index1;\ncuboct.z *= 1.0 - (1.0 - index0 - index1);float type = mod(floor(hash / 8.0), 2.0);\nvec3 rhomb = (1.0 - type) * cube + type * (cuboct + cross(cube, cuboct));vec3 grad = cuboct * 1.22474487139 + rhomb;grad *= (1.0 - 0.042942436724648037 * type) * 3.5946317686139184;return grad;\n}\nvec4 bccNoiseDerivativesPart(vec3 X) {\nvec3 b = floor(X);\nvec4 i4 = vec4(X - b, 2.5);\nvec3 v1 = b + floor(dot(i4, vec4(.25)));\nvec3 v2 = b + vec3(1, 0, 0) + vec3(-1, 1, 1) * floor(dot(i4, vec4(-.25, .25, .25, .35)));\nvec3 v3 = b + vec3(0, 1, 0) + vec3(1, -1, 1) * floor(dot(i4, vec4(.25, -.25, .25, .35)));\nvec3 v4 = b + vec3(0, 0, 1) + vec3(1, 1, -1) * floor(dot(i4, vec4(.25, .25, -.25, .35)));\nvec4 hashes = permute(mod(vec4(v1.x, v2.x, v3.x, v4.x), 289.0));\nhashes = permute(mod(hashes + vec4(v1.y, v2.y, v3.y, v4.y), 289.0));\nhashes = mod(permute(mod(hashes + vec4(v1.z, v2.z, v3.z, v4.z), 289.0)), 48.0);\nvec3 d1 = X - v1; vec3 d2 = X - v2; vec3 d3 = X - v3; vec3 d4 = X - v4;\nvec4 a = max(0.75 - vec4(dot(d1, d1), dot(d2, d2), dot(d3, d3), dot(d4, d4)), 0.0);\nvec4 aa = a * a; vec4 aaaa = aa * aa;\nvec3 g1 = grad(hashes.x); vec3 g2 = grad(hashes.y);\nvec3 g3 = grad(hashes.z); vec3 g4 = grad(hashes.w);\nvec4 extrapolations = vec4(dot(d1, g1), dot(d2, g2), dot(d3, g3), dot(d4, g4));\nvec3 derivative = -8.0 * mat4x3(d1, d2, d3, d4) * (aa * a * extrapolations)\n+ mat4x3(g1, g2, g3, g4) * aaaa;\nreturn vec4(derivative, dot(aaaa, extrapolations));\n}\nvec4 bccNoiseDerivatives_XYBeforeZ(vec3 X) {\nmat3 orthonormalMap = mat3(\n0.788675134594813, -0.211324865405187, -0.577350269189626,\n-0.211324865405187, 0.788675134594813, -0.577350269189626,\n0.577350269189626, 0.577350269189626, 0.577350269189626);\nX = orthonormalMap * X;\nvec4 result = bccNoiseDerivativesPart(X) + bccNoiseDerivativesPart(X + 144.5);\nreturn vec4(result.xyz * orthonormalMap, result.w);\n}const int MAX_ITERATIONS = 32;\nconst float MAX_ITERATIONS_F = 32.0;\nconst float HALF_ITERATIONS = 16.0;out vec4 fragColor;const float PI = 3.14159265;mat2 rot(float a) {\nreturn mat2(cos(a), -sin(a), sin(a), cos(a));\n}void main() {\nvec2 uv = vTextureCoord;\nfloat aspectRatio = uResolution.x/uResolution.y;\nvec2 noiseUv = rot(0.0621 * -1. * 2.0 * PI) *\n(uv * vec2(aspectRatio, 1.) - vec2(0.5, 0.5) * vec2(aspectRatio, 1.)) *\nvec2(0.1700, 1.-0.1700) * 5. * uScale;\nvec4 noise = bccNoiseDerivatives_XYBeforeZ(vec3(noiseUv, uTime * 0.025 + 0.5100 * 2.));\nvec2 noiseOffset = (noise.xy - 0.5) * (0.4600 + 0.01) * 0.25;\nvec4 color = vec4(0.0);\nfor (int i = 0; i < MAX_ITERATIONS; i++) {\nfloat offset = float(i) - HALF_ITERATIONS;\nvec2 st = uv + noiseOffset * (offset / MAX_ITERATIONS_F);\ncolor += texture(uTexture, st);\n}\ncolor /= MAX_ITERATIONS_F;\nfragColor = color;}","#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform sampler2D uTexture;uniform float uTime;\nuniform float uScale;uniform vec2 uResolution;vec4 permute(vec4 t) {\nreturn t * (t * 34.0 + 133.0);\n}vec3 grad(float hash) {\nvec3 cube = mod(floor(hash / vec3(1.0, 2.0, 4.0)), 2.0) * 2.0 - 1.0;\nvec3 cuboct = cube;float index0 = step(0.0, 1.0 - floor(hash / 16.0));\nfloat index1 = step(0.0, floor(hash / 16.0) - 1.0);cuboct.x *= 1.0 - index0;\ncuboct.y *= 1.0 - index1;\ncuboct.z *= 1.0 - (1.0 - index0 - index1);float type = mod(floor(hash / 8.0), 2.0);\nvec3 rhomb = (1.0 - type) * cube + type * (cuboct + cross(cube, cuboct));vec3 grad = cuboct * 1.22474487139 + rhomb;grad *= (1.0 - 0.042942436724648037 * type) * 3.5946317686139184;return grad;\n}\nvec4 bccNoiseDerivativesPart(vec3 X) {\nvec3 b = floor(X);\nvec4 i4 = vec4(X - b, 2.5);\nvec3 v1 = b + floor(dot(i4, vec4(.25)));\nvec3 v2 = b + vec3(1, 0, 0) + vec3(-1, 1, 1) * floor(dot(i4, vec4(-.25, .25, .25, .35)));\nvec3 v3 = b + vec3(0, 1, 0) + vec3(1, -1, 1) * floor(dot(i4, vec4(.25, -.25, .25, .35)));\nvec3 v4 = b + vec3(0, 0, 1) + vec3(1, 1, -1) * floor(dot(i4, vec4(.25, .25, -.25, .35)));\nvec4 hashes = permute(mod(vec4(v1.x, v2.x, v3.x, v4.x), 289.0));\nhashes = permute(mod(hashes + vec4(v1.y, v2.y, v3.y, v4.y), 289.0));\nhashes = mod(permute(mod(hashes + vec4(v1.z, v2.z, v3.z, v4.z), 289.0)), 48.0);\nvec3 d1 = X - v1; vec3 d2 = X - v2; vec3 d3 = X - v3; vec3 d4 = X - v4;\nvec4 a = max(0.75 - vec4(dot(d1, d1), dot(d2, d2), dot(d3, d3), dot(d4, d4)), 0.0);\nvec4 aa = a * a; vec4 aaaa = aa * aa;\nvec3 g1 = grad(hashes.x); vec3 g2 = grad(hashes.y);\nvec3 g3 = grad(hashes.z); vec3 g4 = grad(hashes.w);\nvec4 extrapolations = vec4(dot(d1, g1), dot(d2, g2), dot(d3, g3), dot(d4, g4));\nvec3 derivative = -8.0 * mat4x3(d1, d2, d3, d4) * (aa * a * extrapolations)\n+ mat4x3(g1, g2, g3, g4) * aaaa;\nreturn vec4(derivative, dot(aaaa, extrapolations));\n}\nvec4 bccNoiseDerivatives_XYBeforeZ(vec3 X) {\nmat3 orthonormalMap = mat3(\n0.788675134594813, -0.211324865405187, -0.577350269189626,\n-0.211324865405187, 0.788675134594813, -0.577350269189626,\n0.577350269189626, 0.577350269189626, 0.577350269189626);\nX = orthonormalMap * X;\nvec4 result = bccNoiseDerivativesPart(X) + bccNoiseDerivativesPart(X + 144.5);\nreturn vec4(result.xyz * orthonormalMap, result.w);\n}const int MAX_ITERATIONS = 32;\nconst float MAX_ITERATIONS_F = 32.0;\nconst float HALF_ITERATIONS = 16.0;out vec4 fragColor;const float PI = 3.14159265;mat2 rot(float a) {\nreturn mat2(cos(a), -sin(a), sin(a), cos(a));\n}void main() {\nvec2 uv = vTextureCoord;\nfloat aspectRatio = uResolution.x/uResolution.y;\nvec2 noiseUv = rot(0.0621 * -1. * 2.0 * PI) *\n(uv * vec2(aspectRatio, 1.) - vec2(0.5, 0.5) * vec2(aspectRatio, 1.)) *\nvec2(0.1700, 1.-0.1700) * 5. * uScale;\nvec4 noise = bccNoiseDerivatives_XYBeforeZ(vec3(noiseUv, uTime * 0.025 + 0.5100 * 2.));\nvec2 noiseOffset = (noise.xy - 0.5) * (0.4600 + 0.01) * 0.25;\nvec4 color = vec4(0.0);\nfor (int i = 0; i < MAX_ITERATIONS; i++) {\nfloat offset = float(i) - HALF_ITERATIONS;\nvec2 st = uv + noiseOffset * (offset / MAX_ITERATIONS_F);\ncolor += texture(uTexture, st);\n}\ncolor /= MAX_ITERATIONS_F;\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"downSample":0.25,"depth":false,"uniforms":{},"isBackground":false,"passes":[{"prop":"pass","value":1,"downSample":0.5}]},"id":"effect3"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"normalMap","usesPingPong":false,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform vec2 uResolution;\nvec3 blend (int blendMode, vec3 src, vec3 dst) {\nreturn min(src, dst);\n}out vec4 fragColor;float getHeight(vec4 color) {\nreturn dot(color.rgb, vec3(0.299, 0.587, 0.114));\n}float luma(vec3 color) {\nreturn dot(color, vec3(0.299, 0.587, 0.114));\n}vec3 calculateNormal(vec2 uv, float strength) {\nvec2 texelSize = 1.0 / uResolution;\nfloat tl = getHeight(texture(uTexture, uv + vec2(-texelSize.x, -texelSize.y)));\nfloat tm = getHeight(texture(uTexture, uv + vec2(0.0, -texelSize.y)));\nfloat tr = getHeight(texture(uTexture, uv + vec2(texelSize.x, -texelSize.y)));\nfloat ml = getHeight(texture(uTexture, uv + vec2(-texelSize.x, 0.0)));\nfloat mr = getHeight(texture(uTexture, uv + vec2(texelSize.x, 0.0)));\nfloat bl = getHeight(texture(uTexture, uv + vec2(-texelSize.x, texelSize.y)));\nfloat bm = getHeight(texture(uTexture, uv + vec2(0.0, texelSize.y)));\nfloat br = getHeight(texture(uTexture, uv + vec2(texelSize.x, texelSize.y)));\nfloat dX = (tr + 2.0 * mr + br) - (tl + 2.0 * ml + bl);\nfloat dY = (bl + 2.0 * bm + br) - (tl + 2.0 * tm + tr);\nif (0 == 1) {\ndX = -dX;\ndY = -dY;\n}\nfloat levelExp = 0.2100 * 5.0;\nfloat levelMultiplier = 1.0 + pow(2.0, levelExp);\nfloat effectiveStrength = strength * levelMultiplier;\nvec3 normal = normalize(vec3(-dX * effectiveStrength, -dY * effectiveStrength, 1.0));\nnormal = normal * 0.5 + 0.5;\nreturn normal;\n}vec4 colorMode(vec2 uv, vec3 normalMap) {\nvec4 bg = texture(uTexture, uv);\nvec3 normal = normalMap * 2.0 - 1.0;\nvec2 pos = vec2(vec2(0.5, 0.5).x, vec2(0.5, 0.5).y - 0.01);\nvec3 lightDir = normalize(vec3(pos.x * 2.0 - 1.0, pos.y * 2.0 - 1.0, 0.0000));\nfloat light = max(dot(normal, lightDir), 0.0);\nvec4 normalColor = vec4(vec3(1, 1, 1) * light, 1.0);\nnormalColor.rgb = blend(6, bg.rgb, normalColor.rgb);vec3 composited = mix(bg.rgb, normalColor.rgb, 1.0000);\nreturn vec4(composited, max(bg.a, luma(normalColor.rgb)));\n}vec4 calculateNormalMap(vec2 uv) {\nvec3 normalMap = calculateNormal(uv, 1.0000 * 3.);\nvec4 finalColor;\nfinalColor = colorMode(uv, normalMap);\nreturn finalColor;\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 color = calculateNormalMap(uv);\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false,"texture":{"src":"https://assets.unicorn.studio/media/blue_noise_med.png","sampler":"uBlueNoise"}},"id":"effect4"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"hologram","usesPingPong":false,"speed":0.1,"texture":false,"animating":true,"mouseMomentum":0,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float;\nin vec3 vVertexPosition;\nin vec2 vTextureCoord;\nuniform sampler2D uTexture;\nuniform float uTime;\nvec3 blend (int blendMode, vec3 src, vec3 dst) {\nreturn 2.0 * src + dst - 1.0;\n}float luma(vec3 color) {\nreturn dot(color, vec3(0.299, 0.587, 0.114));\n}vec3 hue(float h, float angle) {\nconst float PI = 3.14159265358979323846;\nreturn vec3(0.5) + 0.5 * cos(h + 2.0 * PI * angle + vec3(0, 2, 4));\n}vec3 getNormal(vec2 uv, float scale) {\nconst vec2 offset1 = vec2(0.0, 0.001);\nconst vec2 offset2 = vec2(0.001, 0.0);float luma1 = luma(texture(uTexture, uv + offset1.xy).rgb);\nfloat luma2 = luma(texture(uTexture, uv + offset2.yx).rgb);\nfloat luma3 = luma(texture(uTexture, uv - offset1.xy).rgb);\nfloat luma4 = luma(texture(uTexture, uv - offset2.yx).rgb);\nvec3 normal = vec3(luma1 - luma3, luma2 - luma4, scale);\nreturn normalize(normal);\n}out vec4 fragColor;\nvoid main() {\nvec2 uv = vTextureCoord;\nvec4 bg = texture(uTexture, uv);\nvec3 normal = getNormal(uv, 0.5000 + 0.0001);\nvec3 lightDir = normalize(vec3(cos(uTime * 0.1), sin(uTime * 0.05), 0.8));\nfloat ndl = dot(normal, lightDir);\nvec3 holoColor = hue(bg.r * 0.5000 * 10., 0.0000 + uTime * 0.05);\nholoColor = blend(15, bg.rgb, holoColor);\nvec3 finalColor = mix(bg.rgb, holoColor, ndl * 0.5000);\nvec4 color = vec4(finalColor, bg.a);\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect5"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"dither","usesPingPong":false,"speed":0.32,"texture":false,"animating":false,"mouseMomentum":0,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;uniform float uTime;uniform vec2 uResolution;uvec2 pcg2d(uvec2 v) {\nv = v * 1664525u + 1013904223u;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nv ^= v >> 16;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nreturn v;\n}float randFibo(vec2 p) {\nuvec2 v = floatBitsToUint(p);\nv = pcg2d(v);\nuint r = v.x ^ v.y;\nreturn float(r) / float(0xffffffffu);\n}const int MAX_LEVEL = 4;\nconst float PI2 = 6.28318530718;float getBayerFromCoordLevelScaled(vec2 pixelpos, float scale) {\nfloat finalBayer = 0.0;\nfloat finalDivisor = 0.0;\nfloat layerMult = 1.0;for(float bayerLevel = float(MAX_LEVEL); bayerLevel >= 1.0; bayerLevel--) {\nfloat bayerSize = exp2(bayerLevel) * 0.5 / scale;\nvec2 bayercoord = mod(floor(pixelpos.xy / bayerSize), 2.0);\nlayerMult *= 4.0;float byxx2 = bayercoord.x * 2.0;finalBayer += mix(byxx2, 3.0 - byxx2, bayercoord.y) / 3.0 * layerMult;\nfinalDivisor += layerMult;\n}return (finalBayer / finalDivisor - 0.006);\n}float getBayerNoise(vec2 st, float delta, float scale) {\nvec2 center = uResolution * 0.5;\nvec2 centered = st * uResolution - center;\nvec2 offset = vec2(\nmod(delta * 0.618033988749895, 16.0),\nmod(delta * 0.381966011250105, 16.0)\n) * 20.;\nvec2 final = (centered + center + offset);\nreturn getBayerFromCoordLevelScaled(final, scale);\n}vec3 dither(vec3 color, vec2 st) {\nfloat delta = floor(uTime);\nvec2 offset = vec2(randFibo(vec2(123,16) + delta), randFibo(vec2(56,96) + delta));\nfloat noise = 0.0;\nnoise = getBayerNoise(st, delta, 0.5);\nfloat dither_threshold = max(0.0001, 0.5800);\nfloat num_levels = 1.0 / dither_threshold;\nreturn floor(color * num_levels + noise) / num_levels;\n}out vec4 fragColor;void main() {\nvec2 uv = vTextureCoord;\nfloat delta = floor(uTime);\nvec4 color = texture(uTexture, uv);if(color.a == 0.) {\nfragColor = vec4(0);\nreturn;\n}color.rgb = mix(color.rgb, dither(color.rgb, vTextureCoord), 0.4800);\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false,"texture":{"src":"https://assets.unicorn.studio/media/blue_noise_med.png","sampler":"uBlueNoise"}},"id":"effect6"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"vignette","usesPingPong":false,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;\nin vec3 vVertexPosition;\nin vec2 vTextureCoord;\nuniform sampler2D uTexture;\nuniform vec2 uResolution;out vec4 fragColor;\nmat2 rot(float a) {\nreturn mat2(cos(a),-sin(a),sin(a),cos(a));\n}\nvoid main() {\nvec2 uv = vTextureCoord;\nvec4 bg = texture(uTexture, uv);\nfloat luma = dot(bg.rgb, vec3(0.299, 0.587, 0.114));\nfloat displacement = (luma - 0.5) * 0.0000 * 0.5;\nvec2 aspectRatio = vec2(uResolution.x/uResolution.y, 1.0);\nvec2 skew = vec2(0.5000, 1.0 - 0.5000);\nfloat halfRadius = 0.5000 * 0.5;\nfloat innerEdge = halfRadius - 1.0000 * halfRadius * 0.5;\nfloat outerEdge = halfRadius + 1.0000 * halfRadius * 0.5;\nvec2 pos = vec2(0.5, 0.5);\nconst float TWO_PI = 6.28318530718;\nvec2 scaledUV = uv * aspectRatio * rot(0.0000 * TWO_PI) * skew;\nvec2 scaledPos = pos * aspectRatio * rot(0.0000 * TWO_PI) * skew;\nfloat radius = distance(scaledUV, scaledPos);\nfloat falloff = smoothstep(innerEdge + displacement, outerEdge + displacement, radius);\nvec3 finalColor;finalColor = mix(bg.rgb, mix(bg.rgb, vec3(0, 0, 0), 1.0000), falloff);float alpha = max(bg.a, falloff * 1.0000);\nvec4 color = mix(bg * (1.-falloff), vec4(finalColor * alpha, alpha), 1.0000);\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect7"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"waterRipple","usesPingPong":true,"speed":0.75,"mouseMomentum":0.16,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;\nin vec3 vVertexPosition;uniform sampler2D uPingPongTexture;const float PI = 3.1415926;\nconst float ITERATIONS = 24.0;out vec4 fragColor;vec3 calculateNormal(sampler2D tex, vec2 uv) {\nfloat stengthScale = mix(3., 7., 0.4200);\nfloat stepScale = mix(1., 3., 0.4200);\nfloat strength = mix(1., stengthScale, 1.0000);\nfloat stepSize = mix(1., stepScale, 1.0000);\nfloat step = stepSize / 1080.;\nfloat left = texture(tex, uv + vec2(-step, 0.0)).r;\nfloat right = texture(tex, uv + vec2(step, 0.0)).r;\nfloat top = texture(tex, uv + vec2(0.0, -step)).r;\nfloat bottom = texture(tex, uv + vec2(0.0, step)).r;\nvec3 normal;\nnormal.x = (right - left) * strength;\nnormal.y = -(bottom - top) * strength;\nnormal.z = -1.0;\nreturn normalize(normal);\n}vec4 drawRipple(vec2 uv) {\nvec2 scaled = mix(uv, (uv - 0.5) * 0.5 + 0.5, 0.4200);\nvec3 normal = calculateNormal(uPingPongTexture, scaled);\nreturn vec4(normal, 1.);\n}const vec3 LIGHT_POS = vec3(2.0, 2.0, 3.0);\nconst vec3 VIEW_POS = vec3(0.0, 0.0, 2.0);\nconst float SPECULAR = 2.4;\nconst float SHININESS = 128.0;vec4 getColor(vec2 uv) {\nreturn drawRipple(uv);\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 color = getColor(uv);\nfragColor = color;\n}","#version 300 es\nprecision highp float;in vec2 vTextureCoord;\nin vec3 vVertexPosition;uniform sampler2D uTexture;const float PI = 3.1415926;\nconst float ITERATIONS = 24.0;float getGaussianWeight(int index) {\nswitch(index) {\ncase 0: return 0.7978845608028654;\ncase 1: return 0.795118932516684;\ncase 2: return 0.7868794322038799;\ncase 3: return 0.7733362336056986;\ncase 4: return 0.7547664553859864;\ncase 5: return 0.7315447328280048;\ncase 6: return 0.704130653528599;\ncase 7: return 0.6730536454899063;\ncase 8: return 0.6388960110447045;\ncase 9: return 0.6022748643096089;\ncase 10: return 0.5638237508206051;\ncase 11: return 0.5241747061566029;\ncase 12: return 0.48394144903828673;\ncase 13: return 0.443704309411472;\ncase 14: return 0.40399737110811773;\ncase 15: return 0.36529817077804383;\ncase 16: return 0.3280201493519873;\ncase 17: return 0.29250790855907144;\ncase 18: return 0.2590351913317835;\ncase 19: return 0.2278053882403838;\ncase 20: return 0.19895427758549736;\ncase 21: return 0.17255463765302306;\ncase 22: return 0.1486223271179862;\ncase 23: return 0.12712341303392466;\ndefault: return 0.0;\n}\n}out vec4 fragColor;vec4 blur(vec2 uv, vec2 dir) {\nvec4 color = vec4(0.0);\nfloat total_weight = 0.0;\nvec4 center = texture(uTexture, uv);\nfloat center_weight = getGaussianWeight(0);\ncolor += center * center_weight;\ntotal_weight += center_weight;\nfor (int i = 1; i <= 11; i++) {\nfloat weight = getGaussianWeight(i);\nfloat offset = mix(0.005, 0.015, 0.6700) * float(i)/11.;\nvec4 sample1 = texture(uTexture, uv + offset * dir);\nvec4 sample2 = texture(uTexture, uv - offset * dir);\ncolor += (sample1 + sample2) * weight;\ntotal_weight += 2.0 * weight;\n}return color / total_weight;\n}const vec3 LIGHT_POS = vec3(2.0, 2.0, 3.0);\nconst vec3 VIEW_POS = vec3(0.0, 0.0, 2.0);\nconst float SPECULAR = 2.4;\nconst float SHININESS = 128.0;vec4 getColor(vec2 uv) {\nreturn blur(uv, vec2(1, 0));\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 color = getColor(uv);\nfragColor = color;\n}","#version 300 es\nprecision highp float;in vec2 vTextureCoord;\nin vec3 vVertexPosition;uniform sampler2D uTexture;const float PI = 3.1415926;\nconst float ITERATIONS = 24.0;float getGaussianWeight(int index) {\nswitch(index) {\ncase 0: return 0.7978845608028654;\ncase 1: return 0.795118932516684;\ncase 2: return 0.7868794322038799;\ncase 3: return 0.7733362336056986;\ncase 4: return 0.7547664553859864;\ncase 5: return 0.7315447328280048;\ncase 6: return 0.704130653528599;\ncase 7: return 0.6730536454899063;\ncase 8: return 0.6388960110447045;\ncase 9: return 0.6022748643096089;\ncase 10: return 0.5638237508206051;\ncase 11: return 0.5241747061566029;\ncase 12: return 0.48394144903828673;\ncase 13: return 0.443704309411472;\ncase 14: return 0.40399737110811773;\ncase 15: return 0.36529817077804383;\ncase 16: return 0.3280201493519873;\ncase 17: return 0.29250790855907144;\ncase 18: return 0.2590351913317835;\ncase 19: return 0.2278053882403838;\ncase 20: return 0.19895427758549736;\ncase 21: return 0.17255463765302306;\ncase 22: return 0.1486223271179862;\ncase 23: return 0.12712341303392466;\ndefault: return 0.0;\n}\n}out vec4 fragColor;vec4 blur(vec2 uv, vec2 dir) {\nvec4 color = vec4(0.0);\nfloat total_weight = 0.0;\nvec4 center = texture(uTexture, uv);\nfloat center_weight = getGaussianWeight(0);\ncolor += center * center_weight;\ntotal_weight += center_weight;\nfor (int i = 1; i <= 11; i++) {\nfloat weight = getGaussianWeight(i);\nfloat offset = mix(0.005, 0.015, 0.6700) * float(i)/11.;\nvec4 sample1 = texture(uTexture, uv + offset * dir);\nvec4 sample2 = texture(uTexture, uv - offset * dir);\ncolor += (sample1 + sample2) * weight;\ntotal_weight += 2.0 * weight;\n}return color / total_weight;\n}const vec3 LIGHT_POS = vec3(2.0, 2.0, 3.0);\nconst vec3 VIEW_POS = vec3(0.0, 0.0, 2.0);\nconst float SPECULAR = 2.4;\nconst float SHININESS = 128.0;vec4 getColor(vec2 uv) {\nreturn blur(uv, vec2(0, 1));\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 color = getColor(uv);\nfragColor = color;\n}","#version 300 es\nprecision highp float;in vec2 vTextureCoord;\nin vec3 vVertexPosition;uniform sampler2D uTexture;\nuniform sampler2D uBgTexture;const float PI = 3.1415926;\nconst float ITERATIONS = 24.0;out vec4 fragColor;vec3 chromatic_aberration(vec3 color, vec2 uv) {\nvec2 offset = (uv - vTextureCoord) * (0.7700 * 0.2);\nvec4 left = texture(uBgTexture, uv - offset);\nvec4 right = texture(uBgTexture, uv + offset);color.r = left.r;\ncolor.b = right.b;return color;\n}vec2 calculateRefraction(vec3 normal, float ior) {\nvec3 I = vec3(0.0, 0.0, 1.0);\nfloat ratio = 1.0 / ior;\nvec3 refracted = refract(I, normal, ratio);\nfloat refractionScale = mix(0.2, 0.4, 0.4200);\nfloat refractionAmount = mix(0.01, refractionScale, 1.0000);\nreturn refracted.xy * refractionAmount;\n}const vec3 LIGHT_POS = vec3(2.0, 2.0, 3.0);\nconst vec3 VIEW_POS = vec3(0.0, 0.0, 2.0);\nconst float SPECULAR = 2.4;\nconst float SHININESS = 128.0;vec3 calculateLighting(vec3 normal, vec2 uv) {\nvec3 N = normal;\nvec3 worldPos = vec3(uv * 2.0 - 1.0, 0.0);\nvec3 lightDir = normalize(LIGHT_POS - worldPos);\nvec3 viewDir = normalize(VIEW_POS - worldPos);\nvec3 reflectDir = reflect(-lightDir, N);\nfloat diff = max(dot(N, lightDir), 0.0);\nvec3 diffuse = vec3(diff);\nfloat spec = pow(max(dot(viewDir, reflectDir), 0.0), SHININESS);\nvec3 specular = vec3(spec * SPECULAR);\nreturn diffuse + specular;\n}vec4 getRipple(vec2 uv) {\nvec3 normal = texture(uTexture, uv).rgb;\nvec2 refractionOffset = calculateRefraction(normal, 1.333);\nvec2 refractedUv = uv + refractionOffset;\nvec3 refractedNormal = texture(uTexture, refractedUv).rgb;vec4 refractedColor = texture(uBgTexture, refractedUv);\nrefractedColor.rgb = chromatic_aberration(refractedColor.rgb, refractedUv);vec3 caustics = calculateLighting(refractedNormal, refractedUv);\nfloat causticsShadow = dot(normal, normalize(vec3(2.0, -2.0, 3.0) - vec3(uv * 2.0 - 1.0, 0.0))) + 1.;\nfloat shadowFactor = causticsShadow;\nvec3 lightingFactor = caustics;shadowFactor = mix(1., shadowFactor, 1.0000);\nlightingFactor = mix(vec3(0), lightingFactor * vec3(1, 1, 1), 1.0000);\nvec4 finalColor = vec4(refractedColor.rgb - vec3(1.-shadowFactor) * vec3(1, 1, 1) + lightingFactor, refractedColor.a);\nreturn finalColor;\n}vec4 getColor(vec2 uv) {\nreturn getRipple(uv);\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 color = getColor(uv);\nfragColor = color;\n}","#version 300 es\nprecision highp float;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uPingPongTexture;\nuniform vec2 uPreviousMousePos;uniform vec2 uMousePos;\nuniform vec2 uResolution;const float PI = 3.1415926;\nconst float TWOPI = 6.2831852;out vec4 fragColor;void main() {\nvec2 aspect = vec2(uResolution.x/uResolution.y, 1);\nvec2 texelSize = (1.0 / (vec2(1080) * aspect)) * mix(1., 8., 0.7500);\nvec2 vUv = vTextureCoord;\nvec2 mPos = mix(uMousePos, (uMousePos - 0.5) * 0.5 + 0.5, 0.4200);\nvec2 pmPos = mix(uPreviousMousePos, (uPreviousMousePos - 0.5) * 0.5 + 0.5, 0.4200);float waveSpeed = 1.;\nfloat damping = mix(0.8, 0.999, 0.7300);\nfloat velocityDamping = damping;\nfloat heightDamping = damping;\nfloat time = 0.5;vec4 data = texture(uPingPongTexture, vUv);\nfloat height = data.r;\nfloat velocity = data.g;float laplacian = 0.0;\nfloat totalWeight = 0.0;\nfloat scaleDiff = 0.4200 * 0.25;\nvec2 clampRegionMin = vec2(0.4200 * 0.5 - scaleDiff);\nvec2 clampRegionMax = vec2(1.0 - 0.4200 * 0.5 + scaleDiff);\nvec2 offset = vec2(texelSize.x, 0.0);\nvec2 neighborUv = clamp(vUv + offset, clampRegionMin, clampRegionMax);\nfloat weight = 1.0 - length(offset) / (length(texelSize) * 2.0);\nlaplacian += texture(uPingPongTexture, neighborUv).r * weight;\ntotalWeight += weight;\noffset = vec2(-texelSize.x, 0.0);\nneighborUv = clamp(vUv + offset, clampRegionMin, clampRegionMax);\nweight = 1.0 - length(offset) / (length(texelSize) * 2.0);\nlaplacian += texture(uPingPongTexture, neighborUv).r * weight;\ntotalWeight += weight;\noffset = vec2(0.0, texelSize.y);\nneighborUv = clamp(vUv + offset, clampRegionMin, clampRegionMax);\nweight = 1.0 - length(offset) / (length(texelSize) * 2.0);\nlaplacian += texture(uPingPongTexture, neighborUv).r * weight;\ntotalWeight += weight;\noffset = vec2(0.0, -texelSize.y);\nneighborUv = clamp(vUv + offset, clampRegionMin, clampRegionMax);\nweight = 1.0 - length(offset) / (length(texelSize) * 2.0);\nlaplacian += texture(uPingPongTexture, neighborUv).r * weight;\ntotalWeight += weight;float avgNeighbors = laplacian / totalWeight;\nlaplacian = avgNeighbors - height;velocity += waveSpeed * waveSpeed * laplacian;\nvelocity *= velocityDamping;\nheight += velocity;\nheight *= heightDamping;float mouseSpeed = distance(mPos * aspect, pmPos * aspect);\nfloat dist = distance(vUv * aspect, mPos * aspect);\nfloat radius = 0.025;\nif (dist < radius && mouseSpeed > 0.0001) {\nfloat drop = cos(dist / radius * PI * time);\nfloat intensity = mouseSpeed * 20.;\nheight += drop * intensity;\n}fragColor = vec4(height, velocity, 0.0, 1.0);\n}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = aTextureCoord;\n}","#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = aTextureCoord;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false,"passes":[{"prop":"pass","value":1,"downSample":0.25},{"prop":"pass","value":2,"downSample":0.25},{"prop":"pass","value":3,"includeBg":true}]},"id":"effect8"}],"options":{"name":"sarcastic (Remix)","fps":60,"dpi":1.5,"scale":1,"includeLogo":false,"isProduction":false},"version":"2.0.0","id":"oNnEl0NXzWNuauKsi4CV"}